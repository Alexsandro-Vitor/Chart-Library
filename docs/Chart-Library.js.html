<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Chart-Library.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Chart-Library.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Class that represents a Chart.
 */
 class Chart {
	/**
	 * @constructor
	 * @param {d3.selection} container - The tag in which the chart will be inserted.
	 * @param {string} id - The id of the chart tag.
	 * @param {Object} position - The position of the chart.
	 * @param {number} position.x - The X coordinate of the chart.
	 * @param {number} position.y - The Y coordinate of the chart.
	 * @param {(number|Object)} margins - The margins of the chart. If a number is passed, all its values will be the same.
	 * @param {number} margins.left - Left margin of the chart.
	 * @param {number} margins.right - Right margin of the chart.
	 * @param {number} margins.top - Upper margin of the chart.
	 * @param {number} margins.bottom - Lower margin of the chart.
	 * @param {Object} dimensions - The dimensions of the chart.
	 * @param {number} dimensions.width - The width of the chart, counting the margins.
	 * @param {number} dimensions.height - The height of the chart, counting the margins.
	 * @param {string} tagClass - The type of chart.
	 */
	constructor(container, id, position, margins, dimensions, tagClass) {
		/**
		 * The tag in which the chart will be inserted.
		 * @member {d3.selection} Chart#container
		 */
		this.container = container;
		
		/**
		 * The id of the chart tag.
		 * @member {string} Chart#id
		 */
		this.id = id;
		
		/**
		 * The X coordinate of the chart.
		 * @member {number} Chart#x
		 */
		/**
		 * The Y coordinate of the chart.
		 * @member {number} Chart#y
		 */
		if ((position == null) || (typeof(position) != "object")) {
			this.x = 0;
			this.y = 0;
		} else {
			this.x = position.x;
			this.y = position.y;
		}
		
		/**
		 * The margins of the chart.
		 * @member {Object} Chart#margins
		 */
		if (margins == null) {
			this.margins = {left:10, right:10, top:10, bottom:10};
		} else if (typeof(margins) == "number") {
			this.margins = {left:margins, right:margins, top:margins, bottom:margins};
		} else {
			this.margins = margins;
		}
		this.margins.left += this.x;
		this.margins.top += this.y;
		
		/**
		 * The inside width of the margin.
		 * @member {number} Chart#width
		 */
		/**
		 * The inside height of the margin.
		 * @member {number} Chart#height
		 */
		if (dimensions == null) {
			this.width = container.attr("width") - this.margins.left - this.margins.right + this.x;
			this.height = container.attr("height") - this.margins.top - this.margins.bottom + this.y;
		} else {
			this.width = dimensions.width - this.margins.left - this.margins.right;
			this.height = dimensions.height - this.margins.top - this.margins.bottom;
		}
		
		/**
		 * The selection of the chart.
		 * @member {d3.selection} Chart#tag
		 * @default d3.selectAll("." + tagClass).select("#" + this.id)
		 */
		this.tag = this.container.append("g")
			.attr("id", this.id)
			.attr("class", tagClass)
			.attr("transform", "translate(" + this.margins.left + "," + this.margins.top + ")");
	}
	
	/** 
	 * Generates an array with equally distanced values.
	 * @param {number} start - The first value of the returned array.
	 * @param {number} size - The size of the returned array.
	 * @param {number} end - The last value of the returned array.
	 * @returns {number[]} Array with equally distanced values.
	 */
	static genSequence(start, size, end) {
		var output = [];
		size--;
		for (var i = 0; i &lt;= size; i++) {
			output.push(start + i * (end - start) / size);
		}
		return output;
	}
	
	/**
	 * Adjusts the domain of a scale and its axis.
	 * @param {d3.scale} scale - The scale to be adjusted.
	 * @param {d3.axis} axis - The axis which uses the scale.
	 * @param {d3.selection} axisGroup - The group in which the axis is.
	 * @param {number} minValue - The minimum value of the new domain.
	 * @param {number} maxValue - The maximum value of the new domain.
	 */
	static adjustScaleDomain(scale, axis, axisGroup, minValue, maxValue) {
		scale.domain([minValue, maxValue]);
		axis.scale(scale);
		axisGroup.call(axis);
	}
	
	/** 
	 * Adds a value to a field if it's null.
	 * @param {Object} array - The array which will have a value added.
	 * @param {(number|string)} field - The name of the field.
	 * @param {(function|number|string)} value - The value added.
	 */
	static addIfNull(array, field, value) {
		if (array[field] == null) array[field] = value;
	}
	
	/**
	 * Sets attributes and events of a selection.
	 * @param {d3.selection} selection - The selection of elements used.
	 * @param {Object} attributes - An object containing functions or constants for attributes of the selected elements.
	 * @param {Object} onEvents - An object containing functions for events.
	 */
	static insertAttributesEvents(selection, attributes, onEvents) {
		//Setting attributes
		for (var attrName in attributes) {
			selection.attr(attrName, attributes[attrName]);
		}
		
		//Setting events
		for (var eventName in onEvents) {
			selection.on(eventName, onEvents[eventName]);
		}
	}
}

/**
 * Class that represents a Histogram.
 * @extends Chart
 */
class Histogram extends Chart {
	/**
	 * @constructor
	 * @param {d3.selection} container - The tag in which the chart will be inserted.
	 * @param {string} id - The id of the chart tag.
	 * @param {Object} position - The position of the chart.
	 * @param {number} position.x - The X coordinate of the chart.
	 * @param {number} position.y - The Y coordinate of the chart.
	 * @param {(number|Object)} margins - The margins of the chart. If a number is passed, all its values will be the same.
	 * @param {number} margins.left - Left margin of the chart.
	 * @param {number} margins.right - Right margin of the chart.
	 * @param {number} margins.top - Upper margin of the chart.
	 * @param {number} margins.bottom - Lower margin of the chart.
	 * @param {Object} dimensions - The dimensions of the chart.
	 * @param {number} dimensions.width - The width of the chart, counting the margins.
	 * @param {number} dimensions.height - The height of the chart, counting the margins.
	 */
	constructor(container, id, position, margins, dimensions) {
		super(container, id, position, margins, dimensions, "histogram");
		
		/**
		 * The X scale of the histogram. Used by the columns.
		 * @member {d3.scale} Histogram#xScale
		 * @default d3.scaleLinear()
		 */
		this.xScale = d3.scaleLinear();
		
		/**
		 * The X scale of the histogram. Used by the axis.
		 * @member {d3.scale} Histogram#xAxisScale
		 * @default d3.scaleOrdinal().range([0, this.width])
		 */
		this.xAxisScale = d3.scaleOrdinal()
			.range([0, this.width]);
		/**
		 * The X axis of the histogram.
		 * @member {d3.axis} Histogram#xAxis
		 * @default d3.axisBottom(this.xAxisScale)
		 */
		this.xAxis = d3.axisBottom(this.xAxisScale);
		/**
		 * The group of the X axis.
		 * @member {d3.selection} Histogram#xAxisGroup
		 */
		this.xAxisGroup = this.tag
			.append("g")
			.attr("class", "xAxis")
			.attr("transform", "translate(0," + this.height  + ")");
		this.xAxisGroup.call(this.xAxis);
		
		/**
		 * The Y scale of the histogram. Used by the axis and the columns.
		 * @member {d3.scale} Histogram#yScale
		 * @default d3.scaleLinear().range([this.height, 0])
		 */
		this.yScale = d3.scaleLinear()
			.range([this.height, 0]);
		/**
		 * The Y axis of the histogram.
		 * @member {d3.axis} Histogram#yAxis
		 * @default d3.axisLeft(this.yScale)
		 */
		this.yAxis = d3.axisLeft(this.yScale);
		/**
		 * The group of the Y axis.
		 * @member {d3.selection} Histogram#yAxisGroup
		 */
		this.yAxisGroup = this.tag
			.append("g")
			.attr("class", "yAxis");
		this.yAxisGroup.call(this.yAxis);
		
		/**
		 * The names of the columns.
		 * @member {string[]} Histogram#xAxisNames
		 */
		this.xAxisNames = [];
		
		/**
		 * The columns of the histogram.
		 * @member {d3.selection} Histogram#colSelection
		 */
		this.colSelection = null;
		
		/**
		 * The color scale of the histogram. Used to set the colors of each column in the histogram.
		 * @member {d3.scale} Histogram#colorScale
		 * @default d3.scaleLinear().domain(Chart.genSequence(0, d3.schemeCategory10.length, d3.schemeCategory10.length - 1)).range(d3.schemeCategory10)
		 */
		this.colorScale = d3.scaleLinear()
			.domain(Chart.genSequence(0, d3.schemeCategory10.length, d3.schemeCategory10.length - 1))
			.range(d3.schemeCategory10);
	}
	
	/** 
	 * Sets the names of the columns of the histogram and modify the axis.
	 * @param {string[]} newDomain - An array of names for the columns.
	 */
	setXDomain(newDomain) {
		this.xAxisNames = newDomain.slice();
		newDomain.push("");
		newDomain.unshift("");
		var sequence = Chart.genSequence(0, newDomain.length, this.width);
		this.xAxisScale
			.domain(newDomain)
			.range(sequence);
		this.xAxis.scale(this.xAxisScale);
		this.xAxisGroup.call(this.xAxis);
		
		this.xScale
			.domain([0, this.xAxisNames.length-1])
			.range([sequence[1], sequence[this.xAxisNames.length]]);
	}
	
	/** 
	 * Inserts data on the histogram and plots it.
	 * @param {number[]} dataset - An array of values for the columns.
	 * @param {Object} attributes - An object containing functions or constants for attributes of the columns.
	 * @param {Object} onEvents - An object containing functions for events.
	 */
	setData(dataset, attributes, onEvents) {
		var colWidth = this.width / (this.xAxisNames.length + 1);
		var thisChart = this;
		if (attributes == null) attributes = [];
		
		//Adjusting the yScale and axis
		Chart.adjustScaleDomain(this.yScale, this.yAxis, this.yAxisGroup, 0, d3.max(dataset));
		
		//Mandatory attributes
		Chart.addIfNull(attributes, "id", (d, i)=>("col" + thisChart.xAxisNames[i]));
		attributes["class"] = "column";
		Chart.addIfNull(attributes, "x", (d, i)=>(thisChart.xScale(i) - colWidth/2));
		Chart.addIfNull(attributes, "y", (d, i)=>(thisChart.yScale(d)));
		Chart.addIfNull(attributes, "width", colWidth);
		Chart.addIfNull(attributes, "height", (d, i)=>(thisChart.height - thisChart.yScale(d)));
		
		//Column selection and color setting
		this.colSelection = this.tag.selectAll(".column").data(dataset).enter().append("rect")
			.attr("fill", (d, i)=>(thisChart.colorScale(i % thisChart.colorScale.domain().length)));
		
		//Insertion of attributes and events
		Chart.insertAttributesEvents(this.colSelection, attributes, onEvents);
	}
	
	/** 
	 * Sets the new colors of the chart. The colors need to be set here because you cant have an "fill" field in an array, since it's the name of an array function.
	 * @param {string[]} newColors - An array of colors for the colorScale to work with.
	 */
	setColorScale(newColors) {
		var sequence = Chart.genSequence(0, newColors.length, newColors.length-1);
		this.colorScale
			.domain(sequence)
			.range(newColors);
		var thisChart = this;
		if (this.colSelection != null) this.colSelection.attr("fill", (d, i)=>(thisChart.colorScale(i % newColors.length)));
	}
}

/**
 * Class that represents a Segment chart.
 * @extends Chart
 */
class Segments extends Chart {
	/**
	 * @constructor
	 * @param {d3.selection} container - The tag in which the chart will be inserted.
	 * @param {string} id - The id of the chart tag.
	 * @param {Object} position - The position of the chart.
	 * @param {number} position.x - The X coordinate of the chart.
	 * @param {number} position.y - The Y coordinate of the chart.
	 * @param {(number|Object)} margins - The margins of the chart. If a number is passed, all its values will be the same.
	 * @param {number} margins.left - Left margin of the chart.
	 * @param {number} margins.right - Right margin of the chart.
	 * @param {number} margins.top - Upper margin of the chart.
	 * @param {number} margins.bottom - Lower margin of the chart.
	 * @param {Object} dimensions - The dimensions of the chart.
	 * @param {number} dimensions.width - The width of the chart, counting the margins.
	 * @param {number} dimensions.height - The height of the chart, counting the margins.
	 */
	constructor(container, id, position, margins, dimensions) {
		super(container, id, position, margins, dimensions, "segmentsChart");
		
		/**
		 * The X scale of the chart. Used by the segments.
		 * @member {d3.scale} Segments#xScale
		 * @default d3.scaleLinear()
		 */
		this.xScale = d3.scaleLinear();
		
		/**
		 * The X scale of the chart. Used by the axis.
		 * @member {d3.scale} Segments#xAxisScale
		 * @default d3.scaleOrdinal().range([0, this.width])
		 */
		this.xAxisScale = d3.scaleOrdinal()
			.range([0, this.width]);
		/**
		 * The X axis of the chart.
		 * @member {d3.axis} Segments#xAxis
		 * @default d3.axisBottom(this.xAxisScale)
		 */
		this.xAxis = d3.axisBottom(this.xAxisScale);
		/**
		 * The group of the X axis.
		 * @member {d3.selection} Segments#xAxisGroup
		 */
		this.xAxisGroup = this.tag
			.append("g")
			.attr("class", "xAxis")
			.attr("transform", "translate(0," + this.height  + ")");
		this.xAxisGroup.call(this.xAxis);
		
		/**
		 * The Y scale of the chart. Used by the axis and the columns.
		 * @member {d3.scale} Segments#yScale
		 * @default d3.scaleLinear().range([this.height, 0])
		 */
		this.yScale = d3.scaleLinear()
			.range([this.height, 0]);
		/**
		 * The Y axis of the chart.
		 * @member {d3.axis} Segments#yAxis
		 * @default d3.axisLeft(this.yScale)
		 */
		this.yAxis = d3.axisLeft(this.yScale);
		/**
		 * The group of the Y axis.
		 * @member {d3.selection} Segments#yAxisGroup
		 */
		this.yAxisGroup = this.tag
			.append("g")
			.attr("class","yAxis");
		this.yAxisGroup.call(this.yAxis);
		
		/**
		 * The names in the X axis.
		 * @member {string[]} Segments#xAxisNames
		 */
		this.xAxisNames = [];
		
		/**
		 * The segments of the chart.
		 * @member {d3.selection} Segments#segSelection
		 */
		this.segSelection = [];
		/**
		 * The dots of the chart.
		 * @member {d3.selection} Segments#dotSelection
		 */
		this.dotSelection = [];
		/**
		 * The ranges of the chart.
		 * @member {d3.selection} Segments#rangeSelection
		 */
		this.rangeSelection = [];
		
		/**
		 * The color scale for dots on the chart. Used to set the colors of each dotGroup in the chart.
		 * @member {d3.scale} Segments#dotColorScale
		 * @default d3.scaleLinear().domain(Chart.genSequence(0, d3.schemeSet1.length, d3.schemeSet1.length - 1)).range(d3.schemeSet1)
		 */
		this.dotColorScale = d3.scaleLinear()
			.domain(Chart.genSequence(0, d3.schemeSet1.length, d3.schemeSet1.length - 1))
			.range(d3.schemeSet1);
		
		/**
		 * The color scale for ranges on the chart. Used to set the colors of each scale in the chart.
		 * @member {d3.scale} Segments#rangeColorScale
		 * @default d3.scaleLinear().domain(Chart.genSequence(0, d3.schemeSet2.length, d3.schemeSet2.length - 1)).range(d3.schemeSet2)
		 */
		this.rangeColorScale = d3.scaleLinear()
			.domain(Chart.genSequence(0, d3.schemeSet2.length, d3.schemeSet2.length - 1))
			.range(d3.schemeSet2);
	}
	
	/** 
	 * Sets the names the X axis.
	 * @param {string[]} newDomain - An array of names for the X axis.
	 */
	setXDomain(newDomain) {
		this.xAxisNames = newDomain.slice();
		var sequence = Chart.genSequence(0, newDomain.length, this.width);
		this.xAxisScale
			.domain(newDomain)
			.range(sequence);
		this.xAxis.scale(this.xAxisScale);
		this.xAxisGroup.call(this.xAxis);
		
		this.xScale
			.domain([0, this.xAxisNames.length-1])
			.range([0, this.width]);
	}
	
	/** 
	 * Inserts data on the chart as segments and plots it.
	 * @param {number[][]} dataset - An array of arrays for each segment.
	 * @param {Object} attributes - An object containing functions or constants for attributes of the segments.
	 * @param {Object} onEvents - An object containing functions for events.
	 */
	setSegments(dataset, attributes, onEvents) {
		var thisChart = this;
		
		//Mandatory attributes
		if (attributes == null) attributes = [];
		Chart.addIfNull(attributes, "id", (d, i)=>("seg" + i));
		attributes["class"] = "segment";
		Chart.addIfNull(attributes, "d", (d, i)=>(thisChart.genSegPath(d)));
		Chart.addIfNull(attributes, "stroke", "black");
		
		this.segSelection = this.tag.selectAll(".segment").data(dataset).enter().append("path")
			.attr("fill", "transparent");
		
		//Insertion of attributes and events
		Chart.insertAttributesEvents(this.segSelection, attributes, onEvents);
	}
	
	/** 
	 * Inserts data on the chart as dots and plots it.
	 * @param {number[][]} dataset - An array of arrays for each dot.
	 * @param {Object} attributes - An object containing functions or constants for attributes of the dots.
	 * @param {Object} onEvents - An object containing functions for events.
	 */
	setDots(dataset, attributes, onEvents) {
		var thisChart = this;
		
		//Mandatory attributes
		if (attributes == null) attributes = [];
		Chart.addIfNull(attributes, "id", (d, i)=>("dotGroup" + i));
		attributes["class"] = "dotGroup";
		Chart.addIfNull(attributes, "r", "5px");
		Chart.addIfNull(attributes, "cx", (d, i)=>thisChart.xScale(i));
		Chart.addIfNull(attributes, "cy", (d, i)=>thisChart.yScale(d));
		
		//Creating the groups
		this.dotSelection = this.tag.selectAll(".dotGroup").data(dataset).enter().append("g")
			.attr("id", attributes["id"])
			.attr("class", attributes["class"])
			.attr("fill", (d, i)=>(thisChart.dotColorScale(i % thisChart.dotColorScale.domain().length)))
			.selectAll(".groupDot").data(d=>d).enter().append("circle");
		
		attributes["id"] = (d, i)=>("dot_" + thisChart.xAxisNames[i]);
		attributes["class"] = "groupDot";
		
		//Insertion of attributes and events
		Chart.insertAttributesEvents(this.dotSelection, attributes, onEvents);
	}
	
	/** 
	 * Inserts data on the chart as ranges and plots it.
	 * @param {number[][][]} dataset - An array of arrays for each range.
	 * @param {number[][]} dataset[i] - The data used to create one range.
	 * @param {number[]} dataset[i][0] - The array with the minimum values of the range.
	 * @param {number[]} dataset[i][1] - The array with the maximum values of the range.
	 * @param {Object} attributes - An object containing functions or constants for attributes of the ranges.
	 * @param {Object} onEvents - An object containing functions for events.
	 */
	setRanges(dataset, attributes, onEvents) {		
		var thisChart = this;
		
		//Mandatory attributes
		if (attributes == null) attributes = [];
		Chart.addIfNull(attributes, "id", (d, i)=>("range" + i));
		attributes["class"] = "range";
		Chart.addIfNull(attributes, "d", (d, i)=>(thisChart.genRangePath(d[0], d[1])));
		
		this.rangeSelection = this.tag.selectAll(".range").data(dataset).enter().append("path")
			.attr("fill", (d, i)=>(thisChart.rangeColorScale(i % thisChart.rangeColorScale.domain().length)));
		
		//Insertion of attributes and events
		Chart.insertAttributesEvents(this.rangeSelection, attributes, onEvents);
	}
	
	/**
	 * Generates a path for a segment.
	 * @param {number[]} d - The array with the values of the path.
	 * @returns {string} A value for the "d" field of the path.
	 */
	genSegPath(d) {
		var path = d3.path();
		path.moveTo(this.xScale(0), this.yScale(d[0]));
		for (var i = 1; i &lt; d.length; i++) {
			path.lineTo(this.xScale(i), this.yScale(d[i]));
		}
		return path.toString();
	}
	
	/**
	 * Generates a path for a range.
	 * @param {number[]} minValues - The array with the minimum values of the range.
	 * @param {number[]} maxValues - The array with the maximum values of the range.
	 * @returns {string} A value for the "d" field of the path.
	 */
	genRangePath(minValues, maxValues) {
		var path = d3.path();
		path.moveTo(this.xScale(0), this.yScale(minValues[0]));
		for (var i = 1; i &lt; minValues.length; i++) {
			path.lineTo(this.xScale(i), this.yScale(minValues[i]));
		}
		for (var i = maxValues.length-1; i >= 0; i--) {
			path.lineTo(this.xScale(i), this.yScale(maxValues[i]));
		}
		path.closePath();
		return path.toString();
	}
	
	/** 
	 * Sets the new colors of the dotGroups. The colors need to be set here because you cant have an "fill" field in an array, since it's the name of an array function.
	 * @param {string[]} newColors - An array of colors for the dotColorScale to work with.
	 */
	setDotColorScale(newColors) {
		this.dotColorScale.range(newColors);
	}
	
	/** 
	 * Sets the new colors of the chart. The colors need to be set here because you cant have an "fill" field in an array, since it's the name of an array function.
	 * @param {string[]} newColors - An array of colors for the rangeColorScale to work with.
	 */
	setRangeColorScale(newColors) {
		this.rangeColorScale.range(newColors);
	}
}

/**
 * Class that represents a Map chart.
 * @extends Chart
 */
class Map extends Chart {
	/**
	 * @constructor
	 * @param {d3.selection} container - The tag in which the chart will be inserted.
	 * @param {string} id - The id of the chart tag.
	 * @param {Object} position - The position of the chart.
	 * @param {number} position.x - The X coordinate of the chart.
	 * @param {number} position.y - The Y coordinate of the chart.
	 * @param {(number|Object)} margins - The margins of the chart. If a number is passed, all its values will be the same.
	 * @param {number} margins.left - Left margin of the chart.
	 * @param {number} margins.right - Right margin of the chart.
	 * @param {number} margins.top - Upper margin of the chart.
	 * @param {number} margins.bottom - Lower margin of the chart.
	 * @param {Object} dimensions - The dimensions of the chart.
	 * @param {number} dimensions.width - The width of the chart, counting the margins.
	 * @param {number} dimensions.height - The height of the chart, counting the margins.
	 */
	constructor(container, id, position, margins, dimensions) {
		super(container, id, position, margins, dimensions, "mapChart");
		
		/**
		 * The projection of the chart.
		 * @member {d3.projection} Map#projection
		 * @default d3.geoMercator()
		 */
		this.projection = d3.geoMercator();
		
		/**
		 * The geoPath of the chart.
		 * @member {d3.path} Map#geoPath
		 * @default d3.geoPath().projection(this.projection)
		 */
		this.geoPath = d3.geoPath().projection(this.projection);
		
		/**
		 * The Paths of the chart.
		 * @member {d3.selection} Map#pathSelection
		 */
		this.pathSelection = null;
		
		/**
		 * The scale between input values and the value used at colorScheme. Its range should stay at [0, 1].
		 * @member {d3.scale} Map#colorScale
		 * @default d3.scalePow()
		 */
		this.colorScale = d3.scalePow();
		
		/**
		 * The color scheme used at the chart. Uses d3.interpolateInferno by default.
		 * @member {d3.scale} Map#colorScheme
		 * @default d3.interpolateInferno
		 */
		this.colorScheme = d3.interpolateInferno;
		
		/**
		 * The function which selects the color of the plots. By default, it uses the fillValue normalized by the colorScale to select a value at the colorScheme.
		 * @member {function} Map#fillFunction
		 * @default (d, i)=>this.colorScheme(this.colorScale(this.fillValue(d, i)))
		 */
		this.fillFunction = (d, i)=>this.colorScheme(this.colorScale(this.fillValue(d, i)));
		
		/**
		 * The function which determines the value of the dataset which will be used on the fillFunction. Default function always returns 1.
		 * @member {function} Map#fillValue
		 * @default (d, i)=>1
		 */
		this.fillValue = (d, i)=>1;
		
		/**
		 * The dots plotted in the chart.
		 * @member {d3.selection} Map#dotSelection
		 */
		this.dotSelection = null;
	}
	
	/** 
	 * Plots the geojson on the chart as paths.
	 * @param {Object} geojson - The data of a geojson file.
	 * @param {Object} attributes - An object containing functions or constants for attributes of the map.
	 * @param {Object} onEvents - An object containing functions for events.
	 */
	setMap(geojson, attributes, onEvents) {
		var thisChart = this;
		
		//Scales the projection to centralize the map
		this.projection.fitExtent([[0, 0], [this.width, this.height]], geojson);
		
		//Mandatory attributes
		if (attributes == null) attributes = [];
		Chart.addIfNull(attributes, "id", (d, i)=>d.properties.L1);
		attributes["class"] = "mapPath";
		Chart.addIfNull(attributes, "d", (d, i)=>thisChart.geoPath(d.geometry));
		
		this.pathSelection = this.tag.selectAll(".mapPath").data(geojson.features).enter().append("path")
			.attr("fill", (d, i)=>thisChart.fillFunction(d, i));
		
		//Insertion of attributes and events
		Chart.insertAttributesEvents(this.pathSelection, attributes, onEvents);
	}
	
	/** 
	 * Plots the dataset on the map chart.
	 * @param {number[][]} dataset - The data to be plotted on the map.
	 * @param {Object} attributes - An object containing functions or constants for attributes of the map.
	 * @param {Object} onEvents - An object containing functions for events.
	 */
	setData(dataset, attributes, onEvents) {
		var thisChart = this;
		
		this.pathSelection.data(dataset)
			.attr("fill", (d, i)=>thisChart.fillFunction(d, i));
		
		//Insertion of attributes and events
		Chart.insertAttributesEvents(this.pathSelection, attributes, onEvents);
	}
	
	/** 
	 * Plots data as dots on the map chart.
	 * @param {number[][]} dataset - The data to be plotted on the map.
	 * @param {Object} attributes - An object containing functions or constants for attributes of the map.
	 * @param {Object} onEvents - An object containing functions for events.
	 */
	setDots(dataset, attributes, onEvents) {
		var thisChart = this;
		
		//Mandatory attributes
		if (attributes == null) attributes = [];
		Chart.addIfNull(attributes, "id", (d, i)=>("dot" + i));
		attributes["class"] = "mapDot";
		Chart.addIfNull(attributes, "r", "3px");
		Chart.addIfNull(attributes, "cx", 10);
		Chart.addIfNull(attributes, "cy", 10);
		
		this.dotSelection = this.tag.selectAll(".mapDot").data(dataset).enter().append("circle")
			.attr("fill", (d, i)=>thisChart.fillFunction(d, i));
		
		//Insertion of attributes and events
		Chart.insertAttributesEvents(this.dotSelection, attributes, onEvents);
	}
	
	/** 
	 * Clears the chart, removing all paths and dots.
	 */
	clear() {
		if (this.pathSelection) {
			this.pathSelection.remove();
			this.pathSelection = null;
		}
		if (this.dotSelection) {
			this.dotSelection.remove();
			this.dotSelection = null;
		}
		if (this.labels) {
			this.labels.tag.remove();
			this.labels = null;
		}
	}
}

/**
 * Class that represents a Scatterplot.
 * @extends Chart
 */
class Scatterplot extends Chart {
	/**
	 * @constructor
	 * @param {d3.selection} container - The tag in which the chart will be inserted.
	 * @param {string} id - The id of the chart tag.
	 * @param {Object} position - The position of the chart.
	 * @param {number} position.x - The X coordinate of the chart.
	 * @param {number} position.y - The Y coordinate of the chart.
	 * @param {(number|Object)} margins - The margins of the chart. If a number is passed, all its values will be the same.
	 * @param {number} margins.left - Left margin of the chart.
	 * @param {number} margins.right - Right margin of the chart.
	 * @param {number} margins.top - Upper margin of the chart.
	 * @param {number} margins.bottom - Lower margin of the chart.
	 * @param {Object} dimensions - The dimensions of the chart.
	 * @param {number} dimensions.width - The width of the chart, counting the margins.
	 * @param {number} dimensions.height - The height of the chart, counting the margins.
	 */
	constructor(container, id, position, margins, dimensions) {
		super(container, id, position, margins, dimensions, "scatteplotChart");
		
		/**
		 * The X scale of the chart.
		 * @member {d3.scale} Scatterplot#xScale
		 * @default d3.scaleLinear().range([0, this.width])
		 */
		this.xScale = d3.scaleLinear()
			.range([0, this.width]);
		/**
		 * The Y scale of the chart.
		 * @member {d3.scale} Scatterplot#yScale
		 * @default d3.scaleLinear().range([this.height, 0])
		 */
		this.yScale = d3.scaleLinear()
			.range([this.height, 0]);
		/**
		 * The top X axis of the chart.
		 * @member {d3.axis} Scatterplot#xAxisTop
		 * @default d3.axisTop(this.xScale)
		 */
		this.xAxisTop = d3.axisTop(this.xScale);
		/**
		 * The bottom X axis of the chart.
		 * @member {d3.axis} Scatterplot#xAxisBottom
		 * @default d3.axisBottom(this.xScale
		 */
		this.xAxisBottom = d3.axisBottom(this.xScale);
		/**
		 * The group of the top X axis.
		 * @member {d3.selection} Scatterplot#xAxisTopGroup
		 */
		this.xAxisTopGroup = this.tag
			.append("g")
			.attr("class", "xAxis");
		this.xAxisTopGroup.call(this.xAxisTop);
		/**
		 * The group of the bottom X axis.
		 * @member {d3.selection} Scatterplot#xAxisBottomGroup
		 */
		this.xAxisBottomGroup = this.tag
			.append("g")
			.attr("class", "xAxis")
			.attr("transform", "translate(0, " + this.height + ")");
		this.xAxisBottomGroup.call(this.xAxisBottom);
		/**
		 * The left Y axis of the chart.
		 * @member {d3.axis} Scatterplot#yAxisLeft
		 * @default d3.axisLeft(this.yScale)
		 */
		this.yAxisLeft = d3.axisLeft(this.yScale);
		/**
		 * The right Y axis of the chart.
		 * @member {d3.axis} Scatterplot#yAxisRight
		 * @default d3.axisRight(this.yScale)
		 */
		this.yAxisRight = d3.axisRight(this.yScale);
		/**
		 * The group of the left Y axis.
		 * @member {d3.selection} Scatterplot#yAxisLeftGroup
		 */
		this.yAxisLeftGroup = this.tag
			.append("g")
			.attr("class", "yAxis")
		this.yAxisLeftGroup.call(this.yAxisLeft);
		/**
		 * The group of the right Y axis.
		 * @member {d3.selection} Scatterplot#yAxisRightGroup
		 */
		this.yAxisRightGroup = this.tag
			.append("g")
			.attr("class", "yAxis")
			.attr("transform", "translate(" + this.width + ", 0)");
		this.yAxisRightGroup.call(this.yAxisRight);
		/**
		 * The dots of the scatterplot.
		 * @member {d3.selection} Scatterplot#dotSelection
		 */
		this.dotSelection = null;
		/**
		 * The color scale of the scatterplot. Used to set the colors of each dot.
		 * @member {d3.scale} Scatterplot#colorScale
		 * @default d3.scaleLinear().domain(Chart.genSequence(0, d3.schemeCategory10.length, d3.schemeCategory10.length - 1)).range(d3.schemeCategory10)
		 */
		this.colorScale = d3.scaleLinear()
			.domain(Chart.genSequence(0, d3.schemeCategory10.length, d3.schemeCategory10.length - 1))
			.range(d3.schemeCategory10);
	}
	
	/** 
	 * Inserts data on the scatterplot and plots it.
	 * @param {number[]} dataset - An array of values for the dots.
	 * @param {Object} attributes - An object containing functions or constants for attributes of the dots.
	 * @param {Object} onEvents - An object containing functions for events.
	 */
	setData(dataset, attributes, onEvents) {
		var thisChart = this;
		
		//Adjusting the scales and axis
		Chart.adjustScaleDomain(this.xScale, this.xAxisTop, this.xAxisTopGroup, d3.min(dataset.map(d=>d[0])), d3.max(dataset.map(d=>d[0])));
		Chart.adjustScaleDomain(this.xScale, this.xAxisBottom, this.xAxisBottomGroup, d3.min(dataset.map(d=>d[0])), d3.max(dataset.map(d=>d[0])));
		Chart.adjustScaleDomain(this.yScale, this.yAxisLeft, this.yAxisLeftGroup, d3.min(dataset.map(d=>d[1])), d3.max(dataset.map(d=>d[1])));
		Chart.adjustScaleDomain(this.yScale, this.yAxisLeft, this.yAxisLeftGroup, d3.min(dataset.map(d=>d[1])), d3.max(dataset.map(d=>d[1])));
		
		//Mandatory attributes
		if (attributes == null) attributes = [];
		Chart.addIfNull(attributes, "id", (d, i)=>("dot" + i));
		attributes["class"] = "dot";
		Chart.addIfNull(attributes, "cx", (d, i)=>(thisChart.xScale(d[0])));
		Chart.addIfNull(attributes, "cy", (d, i)=>(thisChart.yScale(d[1])));
		Chart.addIfNull(attributes, "r", "4px");
		
		//Column selection and color setting
		this.dotSelection = this.tag.selectAll(".dot").data(dataset).enter().append("circle")
			.attr("fill", (d, i)=>(thisChart.colorScale(i % thisChart.colorScale.domain().length)));
		
		//Insertion of attributes and events
		Chart.insertAttributesEvents(this.dotSelection, attributes, onEvents);
	}
	
	/** 
	 * Clears the chart, removing all paths and dots.
	 */
	clear() {
		if (this.dotSelection) {
			this.dotSelection.remove();
			this.dotSelection = null;
		}
	}
}

/**
 * Class that represents a Label table.
 * @extends Chart
 */
class Labels extends Chart {
	/**
	 * @constructor
	 * @param {Chart} chart - The chart of this label table.
	 * @param {string} id - The id of the chart tag.
	 * @param {Object} position - The position of the chart.
	 * @param {number} position.x - The X coordinate of the chart.
	 * @param {number} position.y - The Y coordinate of the chart.
	 * @param {(number|Object)} margins - The margins of the chart. If a number is passed, all its values will be the same.
	 * @param {number} margins.left - Left margin of the chart.
	 * @param {number} margins.right - Right margin of the chart.
	 * @param {number} margins.top - Upper margin of the chart.
	 * @param {number} margins.bottom - Lower margin of the chart.
	 * @param {Object} dimensions - The dimensions of the chart.
	 * @param {number} dimensions.width - The width of the chart, counting the margins.
	 * @param {number} dimensions.height - The height of the chart, counting the margins.
	 */
	constructor(chart, id, position, margins, dimensions) {
		super(chart.tag, id, position, margins, dimensions, "labels");
		
		/**
		 * The chart of this label table.
		 * @member {Chart} Label#chart
		 */
		this.chart = chart;
		
		/**
		 * The rects with the colors of the chart.
		 * @member {d3.selection} Label#colorSelection
		 */
		this.colorSelection = null;
		
		/**
		 * The texts with the ranges for each color of the chart.
		 * @member {d3.selection} Label#textSelection
		 */
		this.textSelection = null;
		
		/**
		 * The border of the label table.
		 * @member {d3.selection} Label#border
		 * @default d3.select("#" + this.chart.id).select("#" + this.id).select(".border")
		 */
		this.border = this.tag.append("rect")
			.attr("class", "border")
			.attr("width", this.width)
			.attr("height", this.height)
			.attr("stroke", "black")
			.attr("fill", "white");
	}
	
	/** 
	 * Inserts data on the labels table.
	 * @param {string[]} colors - An array of colors.
	 * @param {(number[]|string[])} values - An array of labels for the colors.
	 * @param {(function[]|number[])} colorAttributes - An object containing functions or constants for attributes of the color rects.
	 * @param {(function[]|number[])} valueAttributes - An object containing functions or constants for attributes of the label texts.
	 */
	setValues(colors, values, colorAttributes, valueAttributes) {
		var thisChart = this;
		
		//Mandatory attributes of the colors
		if (colorAttributes == null) colorAttributes = [];
		colorAttributes["class"] = "colorPlot";
		Chart.addIfNull(colorAttributes, "x", 0);
		Chart.addIfNull(colorAttributes, "y", (d, i)=>(i * thisChart.height / colors.length));
		Chart.addIfNull(colorAttributes, "width", thisChart.height / colors.length);
		Chart.addIfNull(colorAttributes, "height", thisChart.height / colors.length);
		
		this.colorSelection = this.tag.selectAll("colorPlot").data(colors).enter().append("rect")
			.attr("fill", (d, i)=>d);
		
		//Insertion of attributes
		Chart.insertAttributesEvents(this.colorSelection, colorAttributes, null);
		
		//Mandatory attributes of the texts
		if (valueAttributes == null) valueAttributes = [];
		valueAttributes["class"] = "colorLabel";
		Chart.addIfNull(valueAttributes, "x", colorAttributes["width"] + 5);
		Chart.addIfNull(valueAttributes, "y", colorAttributes["y"]);
		Chart.addIfNull(valueAttributes, "width", thisChart.width - valueAttributes["x"]);
		Chart.addIfNull(valueAttributes, "height", colorAttributes["height"]);
		
		this.textSelection = this.tag.selectAll("colorLabel").data(values).enter().append("text")
			.text(d=>d)
			.attr("dominant-baseline", "hanging");
		
		//Insertion of attributes
		Chart.insertAttributesEvents(this.textSelection, valueAttributes, null);
	}
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Chart.html">Chart</a></li><li><a href="Histogram.html">Histogram</a></li><li><a href="Labels.html">Labels</a></li><li><a href="Map.html">Map</a></li><li><a href="Scatterplot.html">Scatterplot</a></li><li><a href="Segments.html">Segments</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sat May 19 2018 21:47:12 GMT-0300 (E. South America Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
